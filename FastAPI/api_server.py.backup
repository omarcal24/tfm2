from __future__ import annotations
"""
CoverManager API Mock - OpenAPI 3.0.3 100% Compatible
Post-procesamiento del esquema para Swagger Editor
"""
import sys
from pathlib import Path as FilePath


from fastapi import FastAPI, HTTPException, Header, Query, Path
from fastapi.openapi.utils import get_openapi
from pydantic import BaseModel, EmailStr, Field
from typing import Optional, List, Any, Dict
from datetime import datetime, date, time, timedelta
import uuid
import random

ROOT_DIR = FilePath(__file__).parent.parent
sys.path.insert(0, str(ROOT_DIR))

from agent.agent_main import RestaurantBookingAgent

# ==================== MODELOS ====================

class Venue(BaseModel):
    """Restaurante/Local"""
    id: str = Field(..., description="ID Ãºnico del restaurante", example="venue-1")
    name: str = Field(..., description="Nombre del restaurante", example="Restaurante Demo")
    slug: str = Field(..., description="Slug Ãºnico para URLs", example="restaurante-demo")
    timezone: str = Field(default="Europe/Madrid", description="Zona horaria", example="Europe/Madrid")
    currency: str = Field(default="EUR", description="Moneda", example="EUR")

class Shift(BaseModel):
    """Turno del restaurante"""
    id: str = Field(..., description="ID Ãºnico del turno", example="shift-1")
    name: str = Field(..., description="Nombre del turno", example="Comida")
    start_time: time = Field(..., description="Hora de inicio", example="13:00:00")
    end_time: time = Field(..., description="Hora de fin", example="16:00:00")
    venue_id: str = Field(..., description="ID del restaurante", example="venue-1")

class ReservationRequest(BaseModel):
    """PeticiÃ³n para crear reserva"""
    venue_id: str = Field(..., description="ID del restaurante", example="venue-1")
    reservation_date: date = Field(..., description="Fecha de la reserva", example="2024-12-15")
    reservation_time: time = Field(..., description="Hora de la reserva", example="20:00:00")
    party_size: int = Field(..., description="NÃºmero de personas", example=4, ge=1, le=20)
    name: str = Field(..., description="Nombre del cliente", example="Juan PÃ©rez", min_length=2, max_length=100)
    phone: str = Field(..., description="TelÃ©fono del cliente", example="+34666111222")
    email: Optional[EmailStr] = Field(default=None, description="Email del cliente", example="juan@example.com")
    notes: Optional[str] = Field(default=None, description="Notas adicionales", example="Alergia a frutos secos", max_length=500)
    shift_id: Optional[str] = Field(default=None, description="ID del turno (opcional)", example="shift-2")

class Reservation(BaseModel):
    """Reserva"""
    id: str = Field(..., description="ID Ãºnico de la reserva", example="550e8400-e29b-41d4-a716-446655440000")
    venue_id: str = Field(..., description="ID del restaurante", example="venue-1")
    reservation_date: date = Field(..., description="Fecha de la reserva", example="2024-12-15")
    reservation_time: time = Field(..., description="Hora de la reserva", example="20:00:00")
    party_size: int = Field(..., description="NÃºmero de personas", example=4)
    status: str = Field(..., description="Estado de la reserva", example="confirmed")
    name: str = Field(..., description="Nombre del cliente", example="Juan PÃ©rez")
    phone: str = Field(..., description="TelÃ©fono del cliente", example="+34666111222")
    email: Optional[EmailStr] = Field(default=None, description="Email del cliente", example="juan@example.com")
    notes: Optional[str] = Field(default=None, description="Notas adicionales", example="Alergia a frutos secos", max_length=500)
    shift_id: Optional[str] = Field(default=None, description="ID del turno (opcional)", example="shift-2")
    created_at: datetime = Field(..., description="Fecha de creaciÃ³n", example="2024-12-15T10:30:00")
    updated_at: datetime = Field(..., description="Fecha de Ãºltima actualizaciÃ³n", example="2024-12-15T10:30:00")

class AvailabilityQuery(BaseModel):
    """Consulta de disponibilidad"""
    venue_id: str = Field(..., description="ID del restaurante", example="venue-1")
    reservation_date: date = Field(..., description="Fecha a consultar", example="2024-12-15")
    party_size: int = Field(..., description="NÃºmero de personas", example=4, ge=1, le=20)
    shift_id: Optional[str] = Field(default=None, description="ID del turno (opcional)", example="shift-2")

class AvailableSlot(BaseModel):
    """Franja horaria disponible"""
    slot_time: time = Field(..., description="Hora del slot", example="20:00:00")
    available: bool = Field(..., description="Si estÃ¡ disponible", example=True)
    shift_id: Optional[str] = Field(default=None, description="ID del turno (opcional)", example="shift-2")

class ErrorResponse(BaseModel):
    """Respuesta de error estÃ¡ndar"""
    detail: str = Field(..., description="DescripciÃ³n del error", example="Venue not found")

class AgentReservationRequest(BaseModel):
    user_id: str
    session_context: Dict[str, Any] = {}
    ranked_restaurants: List[Dict[str, Any]] = []
    
    class Config:
        extra = "allow"

# ==================== BASE DE DATOS ====================

class SimpleDB:
    def __init__(self):
        self.venues: dict[str, Venue] = {}
        self.shifts: dict[str, Shift] = {}
        self.reservations: dict[str, Reservation] = {}
        self._init_data()
    
    def _init_data(self):
        venue = Venue(
            id="venue-1",
            name="Restaurante Demo",
            slug="restaurante-demo",
            timezone="Europe/Madrid",
            currency="EUR"
        )
        self.venues[venue.id] = venue
        
        shifts_data = [
            {"id": "shift-1", "name": "Comida", "start_time": time(13, 0), "end_time": time(16, 0), "venue_id": "venue-1"},
            {"id": "shift-2", "name": "Cena", "start_time": time(20, 0), "end_time": time(23, 0), "venue_id": "venue-1"}
        ]
        
        for shift_data in shifts_data:
            shift = Shift(**shift_data)
            self.shifts[shift.id] = shift

db = SimpleDB()

# ==================== AGENTE ====================

booking_agent = None

def get_agent():
    """Obtiene o crea la instancia del agente"""
    global booking_agent
    if booking_agent is None:
        print("ðŸ¤– Inicializando Agente de Reservas...")
        booking_agent = RestaurantBookingAgent()
        print("âœ“ Agente listo\n")
    return booking_agent

# ==================== AUTENTICACIÃ“N ====================

API_KEYS = {
    "demo-api-key": "venue-1",
    "dev-api-key-67890": "venue-1"
}

def verify_api_key(x_api_key: str = Header(..., alias="x-api-key", description="API Key de autenticaciÃ³n")):
    """Verifica que la API key sea vÃ¡lida"""
    if x_api_key not in API_KEYS:
        raise HTTPException(status_code=401, detail="Invalid API Key")
    return API_KEYS[x_api_key]

# ==================== APP ====================

app = FastAPI(
    title="ReserveHub API",  # âœ… Nuevo nombre
    description="""
    ## API de ReserveHub para GestiÃ³n de Reservas
    
    Sistema multi-agente para gestiÃ³n inteligente de reservas en restaurantes.
    Desarrollado como TFM - Master en IA Generativa.
    
    ### CaracterÃ­sticas:
    * ðŸª GestiÃ³n de locales (venues)
    * â° GestiÃ³n de turnos (shifts)
    * ðŸ“… Consulta de disponibilidad
    * ðŸ“ CRUD completo de reservas
    
    ### AutenticaciÃ³n:
    Todas las peticiones requieren un header `x-api-key` con una API key vÃ¡lida.
    
    **API Key de prueba**: `demo-api-key`
    """,
    version="1.0.0",
    contact={
        "name": "TFM - Sistema Reservas IA",
        "email": "tu_email@estudiante.com"
    }
)

# ==================== POST-PROCESAMIENTO OPENAPI ====================

def convert_anyof_to_nullable(schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convierte anyOf con type null a nullable para OpenAPI 3.0
    """
    if isinstance(schema, dict):
        # Si tiene anyOf con null, convertir a nullable
        if "anyOf" in schema:
            any_of = schema["anyOf"]
            # Buscar si hay un type null
            non_null_schemas = [s for s in any_of if s.get("type") != "null"]
            has_null = len(non_null_schemas) < len(any_of)
            
            if has_null and len(non_null_schemas) == 1:
                # Reemplazar anyOf con el schema no-null + nullable
                result = non_null_schemas[0].copy()
                result["nullable"] = True
                # Copiar otras propiedades
                for key in schema:
                    if key not in ["anyOf"]:
                        result[key] = schema[key]
                return convert_anyof_to_nullable(result)
        
        # RecursiÃ³n en todos los valores
        return {k: convert_anyof_to_nullable(v) for k, v in schema.items()}
    elif isinstance(schema, list):
        return [convert_anyof_to_nullable(item) for item in schema]
    else:
        return schema

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
        contact=app.contact,
        license_info=app.license_info,
    )
    
    # Forzar versiÃ³n 3.0.3
    openapi_schema["openapi"] = "3.0.3"
    
    # Convertir anyOf a nullable
    openapi_schema = convert_anyof_to_nullable(openapi_schema)
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# ==================== ENDPOINTS ====================

@app.get("/", 
    tags=["Sistema"],
    summary="InformaciÃ³n del servicio"
)
async def root():
    """Endpoint raÃ­z con informaciÃ³n del servicio"""
    return {
        "service": "CoverManager API Mock",
        "version": "2.0.0",
        "status": "running",
        "documentation": "/docs"
    }

@app.get("/health", 
    tags=["Sistema"],
    summary="Health check"
)
async def health():
    """Verifica que el servicio estÃ© funcionando"""
    return {"status": "ok", "timestamp": datetime.now().isoformat()}

# ==================== VENUES ====================

@app.get("/api/venues", 
    response_model=List[Venue],
    tags=["Restaurantes"],
    summary="Listar restaurantes",
    responses={
        200: {"description": "Lista de restaurantes"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"}
    }
)
async def list_venues(x_api_key: str = Header(..., alias="x-api-key")):
    """Listar todos los restaurantes disponibles"""
    verify_api_key(x_api_key)
    return list(db.venues.values())

@app.get("/api/venues/{venue_id}", 
    response_model=Venue,
    tags=["Restaurantes"],
    summary="Obtener restaurante",
    responses={
        200: {"description": "Detalles del restaurante"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"},
        404: {"model": ErrorResponse, "description": "Restaurante no encontrado"}
    }
)
async def get_venue(
    venue_id: str = Path(..., description="ID del restaurante"),
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Obtener detalles de un restaurante especÃ­fico"""
    verify_api_key(x_api_key)
    
    if venue_id not in db.venues:
        raise HTTPException(status_code=404, detail="Venue not found")
    
    return db.venues[venue_id]

# ==================== SHIFTS ====================

@app.get("/api/venues/{venue_id}/shifts", 
    response_model=List[Shift],
    tags=["Turnos"],
    summary="Listar turnos",
    responses={
        200: {"description": "Lista de turnos"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"}
    }
)
async def list_shifts(
    venue_id: str = Path(..., description="ID del restaurante"),
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Listar todos los turnos de un restaurante"""
    verify_api_key(x_api_key)
    
    shifts = [s for s in db.shifts.values() if s.venue_id == venue_id]
    return shifts

# ==================== DISPONIBILIDAD ====================

@app.post("/api/availability", 
    response_model=List[AvailableSlot],
    tags=["Disponibilidad"],
    summary="Consultar disponibilidad",
    responses={
        200: {"description": "Lista de franjas horarias con disponibilidad"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"}
    }
)
async def check_availability(
    query: AvailabilityQuery,
    x_api_key: str = Header(..., alias="x-api-key"),
    max_slots: int = Query(default=3, ge=1, le=20, description="MÃ¡ximo de slots a devolver")
):
    """Consultar disponibilidad de un restaurante"""
    verify_api_key(x_api_key)
    
    available_slots = []
    venue_shifts = [s for s in db.shifts.values() if s.venue_id == query.venue_id]
    
    if query.shift_id:
        venue_shifts = [s for s in venue_shifts if s.id == query.shift_id]
    
    for shift in venue_shifts:
        current = datetime.combine(query.reservation_date, shift.start_time)
        end = datetime.combine(query.reservation_date, shift.end_time)
        
        while current < end:
            slot_time = current.time()
            
            has_reservation = any(
                r.reservation_date == query.reservation_date and 
                r.reservation_time == slot_time and
                r.status in ["confirmed", "seated"]
                for r in db.reservations.values()
            )
            
            available_slots.append(AvailableSlot(
                slot_time=slot_time,
                available=not has_reservation,
                shift_id=shift.id
            ))
            
            current = current + timedelta(minutes=30)
    
    truly_available = [slot for slot in available_slots if slot.available]
    
    random_available_slots = random.sample(
        truly_available, 
        min(max_slots, len(truly_available))
    )
    random_available_slots.sort(key=lambda slot: slot.slot_time)

    return random_available_slots

# ==================== RESERVAS ====================

@app.post("/api/reservations", 
    response_model=Reservation,
    tags=["Reservas"],
    summary="Crear reserva",
    responses={
        200: {"description": "Reserva creada exitosamente"},
        400: {"model": ErrorResponse, "description": "Datos invÃ¡lidos"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"},
        404: {"model": ErrorResponse, "description": "Restaurante no encontrado"}
    }
)
async def create_reservation(
    reservation: ReservationRequest,
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Crear una nueva reserva"""
    verify_api_key(x_api_key)
    
    if reservation.venue_id not in db.venues:
        raise HTTPException(status_code=404, detail="Venue not found")
    
    new_reservation = Reservation(
        id=str(uuid.uuid4()),
        venue_id=reservation.venue_id,
        reservation_date=reservation.reservation_date,
        reservation_time=reservation.reservation_time,
        party_size=reservation.party_size,
        status="confirmed",
        name=reservation.name,
        phone=reservation.phone,
        email=reservation.email,
        notes=reservation.notes,
        shift_id=reservation.shift_id,
        created_at=datetime.now(),
        updated_at=datetime.now()
    )
    
    db.reservations[new_reservation.id] = new_reservation
    return new_reservation

@app.get("/api/reservations", 
    response_model=List[Reservation],
    tags=["Reservas"],
    summary="Listar reservas",
    responses={
        200: {"description": "Lista de reservas"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"}
    }
)
async def list_reservations(
    x_api_key: str = Header(..., alias="x-api-key"),
    venue_id: Optional[str] = Query(default=None, description="Filtrar por restaurante"),
    reservation_date: Optional[date] = Query(default=None, description="Filtrar por fecha"),
    status: Optional[str] = Query(default=None, description="Filtrar por estado")
):
    """Listar reservas con filtros opcionales"""
    verify_api_key(x_api_key)
    
    reservations = list(db.reservations.values())
    
    if venue_id:
        reservations = [r for r in reservations if r.venue_id == venue_id]
    if reservation_date:
        reservations = [r for r in reservations if r.reservation_date == reservation_date]
    if status:
        reservations = [r for r in reservations if r.status == status]
    
    return reservations

@app.get("/api/reservations/{reservation_id}", 
    response_model=Reservation,
    tags=["Reservas"],
    summary="Obtener reserva",
    responses={
        200: {"description": "Detalles de la reserva"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"},
        404: {"model": ErrorResponse, "description": "Reserva no encontrada"}
    }
)
async def get_reservation(
    reservation_id: str = Path(..., description="ID de la reserva"),
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Obtener los detalles completos de una reserva"""
    verify_api_key(x_api_key)
    
    if reservation_id not in db.reservations:
        raise HTTPException(status_code=404, detail="Reservation not found")
    
    return db.reservations[reservation_id]

@app.put("/api/reservations/{reservation_id}", 
    response_model=Reservation,
    tags=["Reservas"],
    summary="Actualizar estado de reserva",
    responses={
        200: {"description": "Reserva actualizada"},
        400: {"model": ErrorResponse, "description": "Estado invÃ¡lido"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"},
        404: {"model": ErrorResponse, "description": "Reserva no encontrada"}
    }
)
async def update_reservation(
    reservation_id: str = Path(..., description="ID de la reserva"),
    status: str = Query(..., description="Nuevo estado (confirmed, seated, cancelled, no_show)"),
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Actualizar el estado de una reserva"""
    verify_api_key(x_api_key)
    
    if reservation_id not in db.reservations:
        raise HTTPException(status_code=404, detail="Reservation not found")
    
    valid_statuses = ["confirmed", "cancelled", "seated", "no_show"]
    if status not in valid_statuses:
        raise HTTPException(
            status_code=400, 
            detail=f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
        )
    
    reservation = db.reservations[reservation_id]
    reservation.status = status
    reservation.updated_at = datetime.now()
    
    return reservation

# 4. ENDPOINT COMPLETO (antes de MAIN, lÃ­nea ~499)

@app.post("/api/reservation-requests",
    tags=["Agente de Reservas"],
    summary="Gestionar reserva con agente LangGraph (Arquitectura HÃ­brida)",
    responses={
        200: {"description": "Resultado del proceso de reserva"},
        400: {"model": ErrorResponse, "description": "Request invÃ¡lido"}
    }
)
async def create_reservation_request(request: AgentReservationRequest):
    """
    Arquitectura HÃ­brida:
    - FastAPI: BÃºsqueda determinista (Google Places + ReserveHub)
    - Agente: AnÃ¡lisis inteligente y respuesta conversacional
    """
    
    print("\n" + "="*60)
    print("ðŸ“¦ REQUEST RECIBIDO DEL FRONTEND")
    print("="*60)
    print(f"ðŸ‘¤ Usuario: {request.user_id}")
    print(f"ðŸ“ UbicaciÃ³n: {request.session_context.get('location', 'N/A')}")
    print(f"ðŸ” Query: {request.session_context.get('original_query', 'N/A')}")
    print("="*60 + "\n")
    
    try:
        context = request.session_context
        
        # ========================================
        # FASE 1: BÃšSQUEDA (FastAPI)
        # ========================================
        if not request.ranked_restaurants:
            print("ðŸ” [FastAPI] Iniciando bÃºsqueda de restaurantes...")
            
            # Importar mÃ³dulos de bÃºsqueda
            import sys
            from pathlib import Path
            project_root = Path(__file__).parent
            if str(project_root) not in sys.path:
                sys.path.insert(0, str(project_root))
            
            try:
                from backend_google_places import PlaceSearchPayload, places_text_search
                from backend_reservehub import enrich_with_availability, ReserveHubClient
            except ImportError:
                try:
                    from backend.backend_google_places import PlaceSearchPayload, places_text_search
                    from backend.backend_reservehub import enrich_with_availability, ReserveHubClient
                except ImportError as e:
                    print(f"âŒ Error importando mÃ³dulos de bÃºsqueda: {e}")
                    return {
                        "status": "failed",
                        "message": "Error de configuraciÃ³n del servidor.",
                        "restaurants": []
                    }
            
            # Preparar bÃºsqueda
            query = context.get("original_query", "restaurante")
            location = context.get("location", "Madrid, EspaÃ±a")
            extras = context.get("extras", "")
            
            full_query = f"{query} {extras}".strip()
            
            print(f"ðŸ—ºï¸  Query: '{full_query}'")
            print(f"ðŸ“ UbicaciÃ³n: {location}")
            
            # Buscar en Google Places
            search_payload = PlaceSearchPayload(
                query=full_query,
                location=location,
                max_travel_time=context.get("mins_to_wait"),
                travel_mode=context.get("travel_mode", "walking"),
                price_level=context.get("price_level"),
                extras=extras
            )
            
            try:
                google_results = places_text_search(search_payload)
            except Exception as e:
                print(f"âŒ Error en Google Places: {e}")
                return {
                    "status": "failed",
                    "message": f"Error en bÃºsqueda: {str(e)}",
                    "restaurants": []
                }
            
            if not google_results:
                print("âš ï¸ No se encontraron resultados")
                return {
                    "status": "failed",
                    "message": "No encontrÃ© restaurantes. Intenta con otros criterios.",
                    "restaurants": []
                }
            
            print(f"âœ… [FastAPI] Encontrados {len(google_results)} restaurantes")
            
            # Enriquecer con disponibilidad
            from datetime import datetime, date as dt_date
            
            reservation_date = dt_date.today()
            if context.get("date"):
                try:
                    reservation_date = datetime.strptime(context["date"], "%Y-%m-%d").date()
                except:
                    pass
            
            print(f"ðŸ”— [FastAPI] Verificando disponibilidad para {reservation_date}...")
            
            try:
                reservehub_client = ReserveHubClient(base_url=BASE_URL, api_key=API_KEYS.get("demo-api-key"))
                enriched_results = enrich_with_availability(
                    google_places_results=google_results[:15],  # Top 15
                    reservation_date=reservation_date,
                    party_size=context.get("party_size", 2),
                    client=reservehub_client
                )
            except Exception as e:
                print(f"âš ï¸ Error en ReserveHub: {e}")
                enriched_results = google_results[:15]
            
            # Convertir a formato para el agente
            request.ranked_restaurants = []
            for r in enriched_results:
                restaurant = {
                    "name": r.get("name", "Restaurante"),
                    "area": r.get("neighborhood", r.get("address", "N/A")[:50] if r.get("address") else "N/A"),
                    "rating": r.get("rating", 0),
                    "price_level": r.get("price_level"),
                    "has_reservehub": r.get("has_reservehub", False),
                    "venue_id": r.get("venue_id"),
                    "available_slots": r.get("available_slots", []),
                    "place_id": r.get("place_id"),
                    "address": r.get("address", ""),
                    "phone": r.get("phone"),
                    "website": r.get("website"),
                    "user_ratings_total": r.get("user_ratings_total", 0)
                }
                request.ranked_restaurants.append(restaurant)
            
            print(f"âœ… [FastAPI] {len(request.ranked_restaurants)} restaurantes preparados para el agente\n")
        
        # ========================================
        # FASE 2: ANÃLISIS (AGENTE)
        # ========================================
        print("ðŸ¤– [AGENTE] Analizando restaurantes...")
        
        # Importar el agente
        try:
            # Asegurar que agent/ estÃ¡ en el path
            agent_dir = project_root / "agent"
            if str(agent_dir) not in sys.path:
                sys.path.insert(0, str(agent_dir))
            
            from agent_main import RestaurantBookingAgent
        except ImportError as e:
            print(f"âŒ Error importando agente: {e}")
            print(f"   Buscando en: {project_root}")
            
            # Fallback: devolver resultados sin anÃ¡lisis del agente
            print("âš ï¸ Usando modo fallback (sin agente)")
            return _fallback_response_without_agent(request)
        
        # Inicializar agente
        agent = get_agent()
        
        # Construir mensaje para el agente
        user_message = _build_message_for_agent(context, request.ranked_restaurants)
        
        print(f"ðŸ’¬ Mensaje al agente: {user_message[:100]}...")
        
        # El agente analiza los restaurantes y genera respuesta
        agent_response = agent.start_conversation(user_message)
        
        print(f"âœ… [AGENTE] Respuesta generada")
        
        # Obtener estado del agente
        status = agent.get_conversation_status()
        
        print(f"ðŸ“Š Estado: {status['status']}")
        print(f"   Necesita input: {status.get('needs_user_input', False)}\n")
        
        # Convertir respuesta del agente a formato API
        result = _format_agent_response(
            agent_response=agent_response,
            agent_status=status,
            agent_state=agent.state,
            restaurants=request.ranked_restaurants
        )
        
        # Resetear agente
        agent.reset()
        
        print("="*60)
        print(f"âœ… Respuesta enviada al frontend: {result['status']}")
        print("="*60 + "\n")
        
        return result
    
    except Exception as e:
        print(f"âŒ ERROR INESPERADO: {str(e)}\n")
        import traceback
        traceback.print_exc()
        
        return {
            "status": "failed",
            "message": f"Error: {str(e)}",
            "restaurants": []
        }


# ============================================
# HELPER FUNCTIONS
# ============================================

def _build_message_for_agent(context: dict, restaurants: list) -> str:
    """
    Construye el mensaje para el agente con contexto de bÃºsqueda y restaurantes.
    
    El agente recibe:
    - Query original del usuario
    - Lista de restaurantes encontrados
    - Contexto de bÃºsqueda (ubicaciÃ³n, fecha, personas)
    """
    parts = []
    
    # Query original
    if context.get("original_query"):
        parts.append(context["original_query"])
    
    # UbicaciÃ³n si no estÃ¡ en la query
    location = context.get("location")
    if location:
        query_lower = context.get("original_query", "").lower()
        location_keywords = [part for part in location.lower().split() if len(part) > 3]
        has_location = any(keyword in query_lower for keyword in location_keywords)
        
        if not has_location:
            parts.append(f"en {location}")
    
    # InformaciÃ³n adicional de contexto
    if context.get("party_size"):
        parts.append(f"para {context['party_size']} personas")
    
    if context.get("date"):
        parts.append(f"el {context['date']}")
    
    if context.get("time"):
        parts.append(f"a las {context['time']}")
    
    # Lista de restaurantes encontrados
    if restaurants:
        parts.append(f"\n\nHe encontrado {len(restaurants)} restaurantes:")
        for idx, r in enumerate(restaurants[:5], 1):  # Top 5
            avail = "âœ“" if r.get("has_reservehub") else "âœ—"
            parts.append(f"{idx}. {r['name']} ({r['rating']}â­) {avail}")
    
    return ". ".join(parts)


def _format_agent_response(
    agent_response: str,
    agent_status: dict,
    agent_state: dict,
    restaurants: list
) -> dict:
    """
    Formatea la respuesta del agente al formato que espera el frontend.
    """
    status_map = {
        "completed": "success",
        "waiting_user": "needs_input",
        "waiting_selection": "needs_input",
        "error": "failed"
    }
    
    current_status = agent_status.get("status", "unknown")
    api_status = status_map.get(current_status, "partial")
    
    # Extraer top 3 si el agente los generÃ³
    top_3 = []
    if agent_state and agent_state.get("top_3_restaurants"):
        top_3_from_agent = agent_state["top_3_restaurants"]
        for r in top_3_from_agent[:3]:
            top_3.append({
                "name": r.name,
                "area": r.address[:50] if r.address else "N/A",
                "rating": r.rating,
                "has_reservehub": r.has_api_booking,
                "available_slots": r.available_times if r.available_times else [],
                "agent_score": getattr(r, 'agent_score', None),
                "score_reasoning": getattr(r, 'score_reasoning', None)
            })
    else:
        # Si el agente no generÃ³ top 3, usar los primeros 3 de la bÃºsqueda
        top_3 = restaurants[:3]
    
    result = {
        "status": api_status,
        "message": agent_response,
        "restaurants": top_3,
        "total_results": len(restaurants),
        "agent_analysis": {
            "reasoning": agent_response,
            "status": current_status
        }
    }
    
    # Si necesita input del usuario
    if agent_status.get("needs_user_input"):
        result["needs_input"] = True
        result["question"] = agent_response
    
    return result


def _fallback_response_without_agent(request: AgentReservationRequest) -> dict:
    """
    Respuesta fallback si el agente no estÃ¡ disponible.
    Devuelve los resultados de bÃºsqueda directamente.
    """
    restaurants = request.ranked_restaurants[:3]
    
    with_availability = sum(1 for r in restaurants if r.get("has_reservehub"))
    
    if with_availability > 0:
        message = f"EncontrÃ© {len(restaurants)} restaurantes. {with_availability} tienen disponibilidad."
    else:
        message = f"EncontrÃ© {len(restaurants)} restaurantes. Contacta directamente para reservar."
    
    return {
        "status": "partial",
        "message": message,
        "restaurants": restaurants,
        "total_results": len(request.ranked_restaurants),
        "note": "Respuesta generada sin anÃ¡lisis del agente (modo fallback)"
    }


# ============================================
# ACTUALIZAR get_agent() si no existe
# ============================================

booking_agent = None

def get_agent():
    """Obtiene o inicializa el agente singleton"""
    global booking_agent
    if booking_agent is None:
        print("ðŸ¤– Inicializando Agente de Reservas...")
        from agent_main import RestaurantBookingAgent
        booking_agent = RestaurantBookingAgent()
        print("âœ“ Agente listo\n")
    return booking_agent

@app.delete("/api/reservations/{reservation_id}",
    tags=["Reservas"],
    summary="Cancelar reserva",
    responses={
        200: {"description": "Reserva cancelada"},
        401: {"model": ErrorResponse, "description": "API Key invÃ¡lida"},
        404: {"model": ErrorResponse, "description": "Reserva no encontrada"}
    }
)
async def cancel_reservation(
    reservation_id: str = Path(..., description="ID de la reserva"),
    x_api_key: str = Header(..., alias="x-api-key")
):
    """Cancelar una reserva"""
    verify_api_key(x_api_key)
    
    if reservation_id not in db.reservations:
        raise HTTPException(status_code=404, detail="Reservation not found")
    
    reservation = db.reservations[reservation_id]
    reservation.status = "cancelled"
    reservation.updated_at = datetime.now()
    
    return {
        "message": "Reservation cancelled successfully",
        "reservation_id": reservation_id,
        "status": "cancelled"
    }

# ==================== MAIN ====================

if __name__ == "__main__":
    import uvicorn
    print("\n" + "="*60)
    print("ðŸš€ CoverManager API Mock v2.0 - OpenAPI 3.0.3")
    print("="*60)
    print("\nðŸ“š DocumentaciÃ³n: http://localhost:8000/docs")
    print("ðŸ”— OpenAPI JSON:  http://localhost:8000/openapi.json")
    print("\nðŸ”‘ API Key: demo-api-key")
    print("\nâœ… OpenAPI 3.0.3 100% Compatible con Swagger Editor")
    print("="*60 + "\n")
    
    uvicorn.run(app, host="0.0.0.0", port=8000)